#!/usr/bin/env bash

# NAME
#   debug-fns - вспомогательные функции дебаггера

# SYNOPSIS 
#   debug-fns [опции] <скрипт> [аргументы]

# DESCRIPTION 
#   debug-fns  — это утилита командной строки, предназначенная для упрощения процесса отладки других скриптов.

breakpoints=''
breakpoint_cond=''

function cleanup() {
  echo -e "\nВыходим из DEBUG-режима"
  trap - DEBUG

  set +o functrace

  echo "Удаляем tmp-файл по пути: $1"
  rm $1
}

function maybe_read_stderr() {
  if [[ $break_on_stderr -eq 1 ]]; then
    echo $1
    return;
  fi

  echo 0
}

function list_bp() {
  for breakpoint in ${breakpoints[@]}; do
    if [[ -n ${lines[$breakpoint]} ]]; then
      cmd=$(echo ${lines[$breakpoint]} | sed 's/^\s\+//g')
      
      echo "Точка остановы на строке $breakpoint > ${cmd}"
    fi
  done
}

function set_breakpoint() {
  local breakpoint_index=$1

  for breakpoint in $breakpoints; do
    if [[ $breakpoint -eq $breakpoint_index ]]; then
      echo "Уже установлена точка остановы на строке $breakpoint_index"
      return;
    fi
  done

  if [[ -z "$breakpoint_index" ]]; then
    list_bp
  elif [[ $(echo $breakpoint_index | grep '^[0-9]$') ]]; then
    if [[ -n ${lines[$breakpoint_index]} ]]; then
      sorted=$(cat <(
        echo $breakpoint_index

        for breakpoint in "$breakpoints"; do
          echo $breakpoint
        done
      ) | sort -n)

      breakpoints=()

      for item in $sorted; do
        breakpoints+=($item)
      done

      echo "Установлена точка остановы на строке $breakpoint_index"
    else
      echo "Строка $breakpoint_index пустая"
    fi
  else
    echo "Индекс $breakpoint_index точки остановы не является числовым"
  fi
}

function clear_bp() {
  local line_number=$1

  if [[ -z "$line_number" ]]; then
    breakpoints=()
    echo "Все точки остановы удалены"
  elif [[ $(echo $line_number | grep '^[0-9]$') ]]; then
    if has_breakpoint $line_number; then
      length=${#breakpoints[@]}

      for (( i=0; i<length; i++ )); do
        if [[ $line_number -eq ${breakpoints[$i]} ]]; then
          unset 'breakpoints[$i]'
          echo "Точка остановы на строке $line_number удалена"
        fi
      done
    else
      echo "На строке $line_number не найдена точка остановы"
    fi
  else
    echo "Переданный аргумент не является числовым"
  fi
}

function set_breakpoint_cond() {
  if [[ -n "$*" ]]; then
    breakpoint_cond=$*

    echo "Установлено условие брейкпоинта: $breakpoint_cond"
  else
    breakpoint_cond=''
    echo "Условие брейкпоинта сброшено"
  fi
}

function has_breakpoint() {
  local line_number=$1

  local i=0

  if [ "$breakpoints" ]; then
    while [[ $i -lt ${#breakpoints[@]} ]]; do
      if [ ${breakpoints[$i]} -eq $line_number ]; then
        return 0
      fi

      let i=$i+1
    done
  fi

  return 1
}

function display_script() {
  local line_number=0

  if [[ ${#lines[@]} -gt 0 ]]; then
    for line in "${lines[@]}"; do
      pointer=' '
      bp='  '

      if [[ $current_line_number -eq $line_number ]]; then
        pointer='>'
      fi

      if has_breakpoint $line_number; then
        bp='bp'
      fi

      echo "$line_number:$pointer$bp $line"
      let line_number=$line_number+1
    done
  else
    echo "Не найдены команды для скрипта по пути: $script_path"
  fi

}

function menu() {
  echo -e '
    bp N            Установить точку остановы на N-строку
    bp              Список всех точек остановы
    bc string       Установить условие прерывания
    bc              Удалить условие прерывания
    cb N            Удалить точку остановы на N-строке
    cb              Удалить все точки остановы
    ds              Вывести оригинальный скрипт
    g               Продолжить выполнение
    s [N]           Пропустить N шагов
    -trace          Включить дебаггинг фукнций и подоболочек
    +trace          Выключить дебаггинг фукнций и подоболочек
    h, ?            Помощь
    q               Выйти из режима дебаггинга
  '
}

function step_in() {
  local cmd args

  while read -e -p 'debugger> ' cmd args; do
    case "$cmd" in
      \? | h)
        menu
        ;;
      bp)
        set_breakpoint $args
        ;;
      cb)
        clear_bp $args
        ;;
      bc)
        set_breakpoint_cond $args
        ;;
      s)
        echo $args
        if [[ $(echo $args | grep '^[0-9]$') ]]; then
          let skip=${args:-1}
        else
          echo 'Передан невалидный аргумент'
        fi

        return
        ;;
      go)
        return
        ;;
      -trace)
        trace=1
        ;;
      +trace)
        trace=0
        ;;
      dt)
        display_script
        ;;
      q)
        exit 0
        ;;
      *) echo "Передана невалидная команда '$cmd'"
    esac
  done
}

function enter_debug() {
  current_line_number=$1
  cmd_status=$2

  echo $cmd_status

  if [[ $skip -gt 0 ]]; then
    let skip=$skip-1
  fi

  if [[ $trace -eq 1 ]]; then
    echo "$PS4 line $current_line_number: ${lines[$current_line_number]}"
  fi

  if has_breakpoint $current_line_number; then
    echo "Найдена точка остановы на строке $current_line_number"
    step_in
  elif [[ -n $breakpoint_cond ]] && eval "$breakpoint_cond"; then
    echo "Выполнено условие: '$breakpoint_cond'"
    step_in
  elif [[ $cmd_status -eq 1 ]]; then
    echo "STDERR на строке $current_line_number"
    step_in
  elif [[ $skip -eq 0 ]]; then
    step_in
  else
    echo "Выполнение строки $current_line_number"
  fi
}
